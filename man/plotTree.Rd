% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotTree.R
\name{plotTree}
\alias{plotTree}
\alias{plotRowTree}
\alias{plotColTree}
\alias{plotColTree,TreeSummarizedExperiment-method}
\alias{plotRowTree,TreeSummarizedExperiment-method}
\title{Plotting tree information enriched with information}
\usage{
plotRowTree(object, ...)

plotColTree(object, ...)

\S4method{plotColTree}{TreeSummarizedExperiment}(
  object,
  relabel_tree = FALSE,
  show_label = FALSE,
  show_highlights = FALSE,
  show_highlight_label = FALSE,
  order_tree = FALSE,
  add_legend = TRUE,
  layout = "circular",
  edge_colour_by = NULL,
  edge_size_by = NULL,
  tip_colour_by = NULL,
  tip_shape_by = NULL,
  tip_size_by = NULL,
  node_colour_by = NULL,
  node_shape_by = NULL,
  node_size_by = NULL,
  colour_highlights_by = NULL,
  by_exprs_values = "counts",
  other_fields = list(),
  ...
)

\S4method{plotRowTree}{TreeSummarizedExperiment}(
  object,
  relabel_tree = FALSE,
  show_label = FALSE,
  show_highlights = FALSE,
  show_highlight_label = FALSE,
  order_tree = FALSE,
  add_legend = TRUE,
  layout = "circular",
  edge_colour_by = NULL,
  edge_size_by = NULL,
  tip_colour_by = NULL,
  tip_shape_by = NULL,
  tip_size_by = NULL,
  node_colour_by = NULL,
  node_shape_by = NULL,
  node_size_by = NULL,
  colour_highlights_by = NULL,
  by_exprs_values = "counts",
  other_fields = list(),
  ...
)
}
\arguments{
\item{object}{a
\code{\link[TreeSummarizedExperiment:TreeSummarizedExperiment-class]{TreeSummarizedExperiment}}
object.}

\item{...}{additional arguments for plotting.}

\item{relabel_tree}{logical scalar, Should the tip labels be relabeled using
the output of \code{getTaxonomyLabels(object, with_rank = TRUE)}? This
has consequences on how data can be merged from \code{other_fields}.
(default: \code{relabel_tree = FALSE})}

\item{show_label, show_highlights, show_highlight_label}{\code{logical}
(scalar), \code{integer} or \code{character} vector. If a \code{logical}
scalar is given, should tip labels be plotted or if a logical vector is
provided, which labels should be shown? If an \code{integer} or
\code{character} vector is provided, it will be converted to a logical
vector. The \code{integer} values must be in the range of 1 and number of
nodes, whereas the values of a \code{character} vector must match values of
the \code{label} column in the node data. In case of a \code{character}
vector only values corresponding to actual labels will be plotted and if no
labels are provided no labels will be shown. (default: \code{FALSE})}

\item{add_legend}{logical scalar. Should legends be plotted?
(default: \code{add_legend = TRUE})}

\item{layout}{layout for the plotted tree. See
\code{\link[ggtree:ggtree]{ggtree}} for details.}

\item{edge_colour_by}{Specification of a column metadata field or a feature
to colour tree edges by, see the by argument in
\code{\link[scater:retrieveCellInfo]{?retrieveCellInfo}} for possible
values.}

\item{edge_size_by}{Specification of a column metadata field or a feature
to size tree edges by, see the by argument in
\code{\link[scater:retrieveCellInfo]{?retrieveCellInfo}} for possible
values.}

\item{tip_colour_by}{Specification of a column metadata field or a feature to
colour tree tips by, see the by argument in
\code{\link[scater:retrieveCellInfo]{?retrieveCellInfo}} for possible
values.}

\item{tip_shape_by}{Specification of a column metadata field or a feature to
shape tree tips by, see the by argument in
\code{\link[scater:retrieveCellInfo]{?retrieveCellInfo}} for possible
values.}

\item{tip_size_by}{Specification of a column metadata field or a feature to
size tree tips by, see the by argument in
\code{\link[scater:retrieveCellInfo]{?retrieveCellInfo}} for possible
values.}

\item{node_colour_by}{Specification of a column metadata field or a feature to
colour tree nodes by. Must be a field from \code{other_fields}.}

\item{node_shape_by}{Specification of a column metadata field or a feature to
shape tree nodes by. Must be a field from \code{other_fields}.}

\item{node_size_by}{Specification of a column metadata field or a feature to
size tree nodes by. Must be a field from \code{other_fields}.}

\item{colour_highlights_by}{Should the highlights be colour differently?
If \code{show_highlights = TRUE}, \code{colour_highlights} will be set to
\code{TRUE} as default. (default: \code{colour_highlights = FALSE})}

\item{by_exprs_values}{A string or integer scalar specifying which assay to
obtain expression values from, for use in point aesthetics - see the
\code{exprs_values} argument in
\code{\link[scater:retrieveCellInfo]{?retrieveCellInfo}}.}

\item{other_fields}{Additional fields to include in the node information
without plotting them.}
}
\value{
a \code{\link{ggtree}} plot
}
\description{
Based on the stored data in a \code{TreeSummarizedExperiment} a tree can
be plotted. From the \code{rowData}, the \code{assays} as well as the
\code{colData} information can be taken for enriching the tree plots with
additional information.
}
\details{
If \code{show_label} or \code{show_highlight_label} have the same length
as the number of nodes, the vector will be used to relabel the nodes.
}
\examples{
library(scater)
library(mia)
# preparation of some data
data(GlobalPatterns)
altExps(GlobalPatterns) <- splitByRanks(GlobalPatterns)
altExp(GlobalPatterns,"Genus") <- addPerFeatureQC(altExp(GlobalPatterns,"Genus"))
rowData(altExp(GlobalPatterns,"Genus"))$log_mean <-
  log(rowData(altExp(GlobalPatterns,"Genus"))$mean)
rowData(altExp(GlobalPatterns,"Genus"))$detected <-
   rowData(altExp(GlobalPatterns,"Genus"))$detected / 100
top_genus <- getTopTaxa(altExp(GlobalPatterns,"Genus"),
                        method="mean",
                        top=100L,
                        abund_values="counts")
#
x <- altExp(GlobalPatterns,"Genus")
plotRowTree(x[rownames(x) \%in\% top_genus,],
            tip_colour_by = "log_mean",
            tip_size_by = "detected")

# plot with tip labels
plotRowTree(x[rownames(x) \%in\% top_genus,],
            tip_colour_by = "log_mean",
            tip_size_by = "detected",
            show_label = TRUE)
# plot with selected labels
labels <- c("Genus:Providencia" = TRUE, "Genus:Morganella" = FALSE,
            "0.961.60" = TRUE)
plotRowTree(x[rownames(x) \%in\% top_genus,],
            tip_colour_by = "log_mean",
            tip_size_by = "detected",
            show_label = labels,
            layout="rectangular")

# plot with labeled edges
plotRowTree(x[rownames(x) \%in\% top_genus,],
            edge_colour_by = "Phylum",
            tip_colour_by = "log_mean")
# if edges are sized, colours might disappear depending on plotting device
plotRowTree(x[rownames(x) \%in\% top_genus,],
            edge_colour_by = "Phylum",
            edge_size_by = "detected",
            tip_colour_by = "log_mean")

# aggregating data over the taxonomic levels for plotting a taxonomic tree
# please note that the original tree of GlobalPatterns is dropped by
# unsplitByRanks
altExps(GlobalPatterns) <- splitByRanks(GlobalPatterns)
top_phyla <- getTopTaxa(altExp(GlobalPatterns,"Phylum"),
                        method="mean",
                        top=10L,
                        abund_values="counts")
altExps(GlobalPatterns) <- lapply(altExps(GlobalPatterns), addPerFeatureQC)
altExps(GlobalPatterns) <-
   lapply(altExps(GlobalPatterns),
          function(y){
              rowData(y)$log_mean <- log(rowData(y)$mean)
              rowData(y)$detected <- rowData(y)$detected / 100
              y
          })
x <- unsplitByRanks(GlobalPatterns)
x <- addTaxonomyTree(x)
plotRowTree(x[rowData(x)$Phylum \%in\% top_phyla,],
            edge_colour_by = "Phylum",
            edge_size_by = "detected",
            tip_colour_by = "log_mean",
            node_colour_by = "log_mean")
}
\seealso{
\code{\link[mia:splitByRanks]{splitByRanks}}
}
